<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="i-dati-sul-sovraffollamento-carcerario-in-italia" class="level1">
<h1>I Dati sul Sovraffollamento Carcerario in Italia</h1>
<p>Author: Marco Dalla Stella<br>
Contact: <a href="mailto:md3934@columbia.edu">md3934@columbia.edu</a></p>
<section id="introduzione" class="level2">
<h2 class="anchored" data-anchor-id="introduzione">Introduzione</h2>
<p>Questo progetto si propone di fornire dati aggregati e aggiornati sul problema del sovraffollamento carcerario in Italia. È stato sviluppato in supporto al lavoro condotto dall’<a href="https://www.antigone.it">Associazione Antigone</a>, un’organizzazione impegnata nella difesa dei diritti dei detenuti.</p>
<p>Il progetto si ispira al <a href="https://www.data-liberation-project.org/about/">Data Liberation Project</a>, un’iniziativa che mira a identificare, ottenere, ripulire, documentare e pubblicare dati governativi di pubblico interesse.</p>
<p>La necessità nasce dal fatto che i dati sul sovraffollamento carcerario in Italia sono sparsi e di difficile consultazione. Il Ministero della Giustizia mette a disposizione principalmente due tipologie di dati:</p>
<p>1 I <a href="ttps://www.giustizia.it/giustizia/it/mg_1_14_1.page?contentId=SST459023">bollettini mensili</a>: pubblicati con cadenza mensile, contengono informazioni riguardo alla capacità regolamentare, al totale dei detenuti, al numero di detenute, e al totale dei detenuti di origine straniera per ogni centro di detenzione in Italia. I dati sono pubblicati in formato tabellare sul sito del Ministero e non in un formato strutturato come un file .csv.</p>
<p>2 <a href="https://www.giustizia.it/giustizia/page/it/istituti_penitenziari">Schede istituti penitenziari</a>: forniscono informazioni più dettagliate su ogni istituto penitenziario, inclusi dettagli come il numero di posti non disponibili. Questi dati sono essenziali per comprendere il fenomeno del sovraffollamento, in quanto la capienza regolamentare spesso non riflette quella effettiva. Le informazioni sono pubblicate in tabelle distribuite sulle singole pagine di ciascun istituto e, una volta aggiornate, le versioni precedenti non sono più disponibili.</p>
</section>
<section id="dati-principali" class="level2">
<h2 class="anchored" data-anchor-id="dati-principali">Dati Principali</h2>
<ul>
<li><a href="outputs/clean/bulletines.csv">Bollettini mensili</a>: contiene tutti i bollettini mensili emessi da gennaio 2019 a oggi (con l’eccezione di ottobre 2021, che sembra mancare sul sito del Ministero).</li>
<li><a href="outputs/clean/institutes.csv">Dati per istituto</a>: include tutti gli aggiornamenti alle singole pagine degli istituti penitenziari, a partire da ottobre 2024, quando lo scraper è stato finalizzato e programmato per avviarsi con cadenza giornaliera.</li>
</ul>
</section>
<section id="dati-di-supporto" class="level2">
<h2 class="anchored" data-anchor-id="dati-di-supporto">Dati di Supporto</h2>
<ul>
<li><a href="outputs/clean/bulletines_links.csv">Bollettini links</a>: contiene i link ai vari bollettini mensili pubblicati sul sito del Ministero.</li>
<li><a href="outputs/clean/institutes_info.csv">Informazioni istituti</a>: contiene informazioni aggiornate sugli istituti penitenziari in Italia, inclusi tipologia, indirizzo e coordinate geografiche.</li>
</ul>
</section>
<section id="dataset-per-visualizzazioni" class="level2">
<h2 class="anchored" data-anchor-id="dataset-per-visualizzazioni">Dataset per Visualizzazioni</h2>
<ul>
<li><a href="outputs/viz/bulletines_totals.csv">Bollettini Totali</a>: contiene i dati mensili totali, aggregati per data.</li>
<li><a href="outputs/viz/institutes_totals.csv">Istituti Totali</a>: aggrega i dati delle schede istituti per data di aggiornamento.</li>
<li><a href="outputs/viz/institutes_most_recent.csv">Istituti - Ultimo Aggiornamento</a>: contiene l’ultimo aggiornamento disponibile delle informazioni presenti sulle schede istituti. Poiché le schede non vengono aggiornate simultaneamente, è possibile che alcuni istituti abbiano aggiornamenti più recenti di altri.</li>
</ul>
</section>
<section id="notebooks" class="level2">
<h2 class="anchored" data-anchor-id="notebooks">Notebooks</h2>
<p>Questo progetto si avvale dei seguenti notebooks:</p>
<section id="bollettini" class="level4">
<h4 class="anchored" data-anchor-id="bollettini">Bollettini</h4>
<ol type="1">
<li><a href="notebooks/1_Bulletines_1_Links_scraper.ipynb">Links Scraper</a>: ottiene i link ai bollettini mensili utilizzando browser automation con Playwright. Visita la pagina del Ministero, effettua la ricerca e raccoglie i link pertinenti.</li>
<li><a href="notebooks/1_Bulletines_2_Scraper.ipynb">Scraper</a>: scarica i dati dei bollettini utilizzando i link raccolti nel notebook precedente.</li>
<li><a href="notebooks/1_Bulletines_3_Clean.ipynb">Clean</a>: ripulisce e standardizza i dati, ad esempio omologando i nomi dei vari istituti (es. “Milano S. Vittore” e “Milano San Vittore”).</li>
<li><a href="notebooks/1_Bulletines_5_Analysis_.ipynb">Analisi</a>: esegue l’analisi dei dati ripuliti e crea i file necessari per le visualizzazioni.</li>
<li><a href="notebooks/1_Bulletines_4_Monthly_scraper.ipynb">Scraper mensile</a>: eseguito automaticamente ogni mese per scaricare i dati relativi al mese appena trascorso.</li>
</ol>
</section>
<section id="schede-istituti-penitenziari" class="level4">
<h4 class="anchored" data-anchor-id="schede-istituti-penitenziari">Schede Istituti Penitenziari</h4>
<ul>
<li><a href="notebooks/2_Institutes_1_Info_scraper.ipynb">Informazioni istituti Scraper</a>: ottiene informazioni aggiornate sugli istituti penitenziari attualmente in funzione.</li>
<li><a href="notebooks/3_Institutes_3_Analysis.ipynb">Analisi</a>: eseguito automaticamente ogni giorno per raccogliere i dati aggiornati dalle schede istituti.</li>
<li><a href="notebooks/2_Institutes_2_Daily_scraper.ipynb">Scraper giornaliero</a>: esegue l’analisi dei dati e crea i file per le visualizzazioni.</li>
</ul>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>